<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>&quot;contribs/gmf/src/datasource/Manager&quot; | ngeo</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="../assets/js/search.js" data-base="..">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="../index.html" class="title">ngeo</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="../globals.html">Globals</a>
				</li>
				<li>
					<a href="_contribs_gmf_src_datasource_manager_.html">&quot;contribs/gmf/src/datasource/Manager&quot;</a>
				</li>
			</ul>
			<h1>External module &quot;contribs/gmf/src/datasource/Manager&quot;</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<section class="tsd-panel-group tsd-index-group">
				<h2>Index</h2>
				<section class="tsd-panel tsd-index-panel">
					<div class="tsd-index-content">
						<section class="tsd-index-section ">
							<h3>Variables</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-variable tsd-parent-kind-external-module"><a href="_contribs_gmf_src_datasource_manager_.html#exports" class="tsd-kind-icon">exports</a></li>
							</ul>
						</section>
					</div>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group ">
				<h2>Variables</h2>
				<section class="tsd-panel tsd-member tsd-kind-variable tsd-parent-kind-external-module">
					<a name="exports" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagConst">Const</span> exports</h3>
					<div class="tsd-signature tsd-kind-icon">exports<span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">exports</span><span class="tsd-signature-symbol"> =&nbsp;class {/*** The GeoMapFish DataSources Manager is responsible of listenening to the* c2cgeoportal&#x27;s themes to create instances of &#x60;ngeo.datasource.DataSource&#x60;* objects with the layer definitions found and push them in the* &#x60;ngeox.datasource.DataSources&#x60; collection. The Manager must be initialized* with the app&#x27;s map using the setDatasourcseMap() method.** When changing theme, these data sources are cleared then re-created.** @struct* @param {angular.IQService} $q Angular q service* @param {!angular.IScope} $rootScope Angular rootScope.* @param {angular.ITimeoutService} $timeout Angular timeout service.* @param {gmf.theme.Themes} gmfThemes The gmf Themes service.* @param {gmf.layertree.TreeManager} gmfTreeManager The gmf TreeManager service.* @param {!ngeo.map.BackgroundLayerMgr} ngeoBackgroundLayerMgr Background layer*     manager.* @param {ngeo.datasource.DataSources} ngeoDataSources Ngeo data sources service.*     data sources service.* @param {!ngeo.map.LayerHelper} ngeoLayerHelper Ngeo Layer Helper.* @param {!ngeo.filter.RuleHelper} ngeoRuleHelper Ngeo rule helper service.* @param {!ngeo.misc.WMSTime} ngeoWMSTime wms time service.* @param {!gmf.datasource.WFSAliases} gmfWFSAliases Gmf WFS aliases service.* @ngInject* @ngdoc service* @ngname gmfDataSourcesManager*/constructor($q, $rootScope, $timeout, gmfThemes, gmfTreeManager,ngeoBackgroundLayerMgr, ngeoDataSources, ngeoLayerHelper, ngeoRuleHelper,ngeoWMSTime, gmfWFSAliases) {// &#x3D;&#x3D;&#x3D; Injected properties &#x3D;&#x3D;&#x3D;/*** @type {angular.IQService}* @private*/this.q_ &#x3D; $q;/*** @type {!angular.IScope}* @private*/this.rootScope_ &#x3D; $rootScope;/*** @type {angular.ITimeoutService}* @private*/this.timeout_ &#x3D; $timeout;/*** @type {gmf.theme.Themes}* @private*/this.gmfThemes_ &#x3D; gmfThemes;/*** @type {gmf.layertree.TreeManager}* @private*/this.gmfTreeManager_ &#x3D; gmfTreeManager;/*** @type {!ngeo.map.BackgroundLayerMgr}* @private*/this.ngeoBackgroundLayerMgr_ &#x3D; ngeoBackgroundLayerMgr;/*** @type {ngeo.datasource.DataSources}* @private*/this.ngeoDataSources_ &#x3D; ngeoDataSources;/*** The collection of DataSources from ngeo, which gets updated by this* service. When the theme changes, first we remove all data sources, then* the &#x27;active&#x27; data source are added here.* @type {ngeox.datasource.DataSources}* @private*/this.dataSources_ &#x3D; ngeoDataSources.collection;/*** @type {!ngeo.map.LayerHelper}* @private*/this.ngeoLayerHelper_ &#x3D; ngeoLayerHelper;/*** @type {!ngeo.filter.RuleHelper}* @private*/this.ngeoRuleHelper_ &#x3D; ngeoRuleHelper;/*** @type {!ngeo.misc.WMSTime}* @private*/this.ngeoWMSTime_ &#x3D; ngeoWMSTime;/*** @type {!gmf.datasource.WFSAliases}* @private*/this.gmfWFSAliases_ &#x3D; gmfWFSAliases;// &#x3D;&#x3D;&#x3D; Inner properties &#x3D;&#x3D;&#x3D;/*** While loading a new theme, this is where all of the created data sources* are put using the id as key for easier find in the future.* @type {Object.&lt;number, gmf.datasource.OGC&gt;}* @private*/this.dataSourcesCache_ &#x3D; {};/*** A reference to the dimensions object.* @type {ngeox.Dimensions|undefined}* @private*/this.dimensions_;/*** The function to call to unregister the &#x60;watch&#x60; event on the dimensions* object properties.* @type {?Function}* @private*/this.dimensionsWatcherUnregister &#x3D; null;/*** The cache of layertree leaf controller, i.e. those that are added to* the tree manager. When treeCtrl is added in this cache, it&#x27;s given* a reference to its according data source.* @type {gmfx.datasource.ManagerTreeCtrlCache}* @private*/this.treeCtrlCache_ &#x3D; {};/*** The function to call to unregister the &#x60;watchCollection&#x60; event on* the root layer tree controller children.* @type {?Function}* @private*/this.treeCtrlsUnregister_ &#x3D; null;// &#x3D;&#x3D;&#x3D; Events &#x3D;&#x3D;&#x3D;olEvents.listen(this.ngeoBackgroundLayerMgr_,&#x27;change&#x27;,this.handleNgeoBackgroundLayerChange_,this);olEvents.listen(this.gmfThemes_, &#x27;change&#x27;, this.handleThemesChange_, this);}/*** Set the map to use with your datasources.* @param {!ol.Map} map The map to use.* @export*/setDatasourceMap(map) {this.ngeoDataSources_.map &#x3D; map;}/*** @param {!ngeox.Dimensions} dimensions A reference to the dimensions*     object to keep a reference of in this service.*/setDimensions(dimensions) {if (this.dimensionsWatcherUnregister) {this.dimensionsWatcherUnregister();}this.dimensions_ &#x3D; dimensions;this.dimensionsWatcherUnregister &#x3D; this.rootScope_.$watch(() &#x3D;&gt; this.dimensions_,this.handleDimensionsChange_.bind(this),true);this.handleDimensionsChange_();}/*** Called when the dimensions change. Update all affected layer&#x27;s filters.* @private*/handleDimensionsChange_() {// Create a layer list to update each one only onceconst layers &#x3D; [];const layerIds &#x3D; [];const dataSources &#x3D; this.dataSources_.getArray();for (const dataSource of dataSources) {if (dataSource.dimensionsFiltersConfig) {for (const key in dataSource.dimensionsFiltersConfig) {if (dataSource.dimensionsFiltersConfig[key].value &#x3D;&#x3D;&#x3D; null) {const layer &#x3D; this.getDataSourceLayer_(dataSource);if (layer &#x3D;&#x3D; undefined) {return;}const id &#x3D; olUtilGetUid(layer);if (layerIds.indexOf(id) &#x3D;&#x3D; -1) {layers.push(layer);layerIds.push(id);}}}}}layers.forEach(this.updateLayerFilter_.bind(this));}/*** Called when the themes change. Remove any existing data sources first,* then create and add data sources from the loaded themes.* @private*/handleThemesChange_() {// (1) Clearthis.clearDataSources_();if (this.treeCtrlsUnregister_) {this.treeCtrlsUnregister_();}this.clearTreeCtrlCache_();// (2) Re-create data sources and event listenersthis.gmfThemes_.getOgcServersObject().then((ogcServers) &#x3D;&gt; {const promiseThemes &#x3D; this.gmfThemes_.getThemesObject().then((themes) &#x3D;&gt; {// Create a DataSources for each themefor (const theme of themes) {for (const child of theme.children) {googAsserts.assert(child);this.createDataSource_(child, child, ogcServers);}}});const promiseBgLayers &#x3D; this.gmfThemes_.getBackgroundLayersObject().then((backgroundLayers) &#x3D;&gt; {// Create a DataSource for each background layerfor (const backgroundLayer of backgroundLayers) {this.createDataSource_(null, backgroundLayer, ogcServers);}});// Then add the data sources that are active in the ngeo collectionthis.q_.all([promiseThemes, promiseBgLayers]).then(() &#x3D;&gt; {this.treeCtrlsUnregister_ &#x3D; this.rootScope_.$watchCollection(() &#x3D;&gt; {if (this.gmfTreeManager_.rootCtrl) {return this.gmfTreeManager_.rootCtrl.children;}},this.handleTreeManagerRootChildrenChange_.bind(this));});});}/*** Called when the list of tree controllers within the tree manager* root controller changes. In other words, this method is called* after nodes are being added added or removed from the tree,* i.e. from the child nodes collection.** A timeout is required  because the collection event is fired before* the leaf nodes are created and they are the ones we&#x27;re looking for here.** This method handles the registration/unregistration of tree nodes that* are added or removed, pushing it to the cache or removing it from the* cache.** @param {Array.&lt;ngeo.layertree.Controller&gt;|undefined} value List of tree*     controllers.* @private*/handleTreeManagerRootChildrenChange_(value) {this.timeout_(() &#x3D;&gt; {// (1) No need to do anything if the value is not setif (!value) {return;}// (2) Collect &#x27;leaf&#x27; treeCtrlsconst newTreeCtrls &#x3D; [];const visitor &#x3D; (treeCtrls, treeCtrl) &#x3D;&gt; {const node &#x3D; /** @type {!gmfThemes.GmfGroup|!gmfThemes.GmfLayer} */ (treeCtrl.node);const children &#x3D; node.children;if (!children) {treeCtrls.push(treeCtrl);}};for (let i &#x3D; 0, ii &#x3D; value.length; i &lt; ii; i++) {value[i].traverseDepthFirst(visitor.bind(this, newTreeCtrls));}// (3) Add new &#x27;treeCtrls&#x27;for (let i &#x3D; 0, ii &#x3D; newTreeCtrls.length; i &lt; ii; i++) {const newTreeCtrl &#x3D; newTreeCtrls[i];const cacheItem &#x3D; this.getTreeCtrlCacheItem_(newTreeCtrl);if (!cacheItem) {this.addTreeCtrlToCache_(newTreeCtrl);}}// (4) Remove treeCtrls that are no longer in the newTreeCtrlconst cache &#x3D; this.treeCtrlCache_;for (const id in this.treeCtrlCache_) {const item &#x3D; cache[id];if (!newTreeCtrls.includes(item.treeCtrl)) {this.removeTreeCtrlCacheItem_(item);}}});}/*** Remove the data sources from the ngeo collection that are in the cache,* i.e. those created by this service, then clear the cache.* @private*/clearDataSources_() {// (1) Remove data sources from ngeo collectionconst dataSources &#x3D; this.dataSources_.getArray();for (let i &#x3D; dataSources.length - 1, ii &#x3D; 0; i &gt;&#x3D; ii; i--) {if (this.dataSourcesCache_[dataSources[i].id]) {// Use the &#x60;remove&#x60; method of the &#x60;ol.Collection&#x60; object for it// to update its length accordingly and trigger the REMOVE event as// well.this.dataSources_.remove(dataSources[i]);}}// (2) Clear the cacheolObj.clear(this.dataSourcesCache_);}/*** Create a data source using the information on the node, group node* and OGC servers. If the node has children, then we loop in those to get* leaf nodes. Only leaf nodes end up creating a data source. If a data* source with the same id already exists, then the node is skipped.** Once a data source is created, it is added to the data sources cache.** @param {gmfThemes.GmfGroup} firstLevelGroup The first level group node.* @param {!gmfThemes.GmfGroup|!gmfThemes.GmfLayer} node The node, which*     may have children or not.* @param {!gmfThemes.GmfOgcServers} ogcServers OGC servers.* @private*/createDataSource_(firstLevelGroup, node, ogcServers) {const children &#x3D; node.children;// (1) Group node (node that has children). Loop in the children//     individually and create a data source for each one of them. The//     group node itself is **skipped**.if (children) {for (const child of children) {googAsserts.assert(child);this.createDataSource_(firstLevelGroup, child, ogcServers);}return;}// From there on, the node is a layer node.const gmfLayer &#x3D; /** @type gmfThemes.GmfLayer */ (node);// (2) Skip layer node if a data source with the same id existsconst id &#x3D; olUtilGetUid(gmfLayer);if (this.dataSourcesCache_[id]) {return;}// From there on, a data source will be createdconst meta &#x3D; gmfLayer.metadata;const ogcType &#x3D; gmfLayer.type;let maxResolution;let minResolution;let ogcLayers;let ogcServer;let wmtsLayer;let wmtsUrl;let ogcImageType;let timeProperty;if (ogcType &#x3D;&#x3D;&#x3D; gmfThemeThemes.NodeType.WMTS) {// (3) Manage WMTSconst gmfLayerWMTS &#x3D; /** @type {gmfThemes.GmfLayerWMTS} */ (gmfLayer);// Common options for WMTSwmtsLayer &#x3D; gmfLayerWMTS.layer;wmtsUrl &#x3D; gmfLayerWMTS.url;maxResolution &#x3D; meta.maxResolution;minResolution &#x3D; meta.minResolution;// OGC Layersconst layers &#x3D; meta.queryLayers || meta.wmsLayers;if (layers) {ogcLayers &#x3D; layers.split(&#x27;,&#x27;).map((layer) &#x3D;&gt; {return {maxResolution: maxResolution,minResolution: minResolution,name: layer,queryable: true};});}// OGC Serverif (meta.ogcServer &amp;&amp; ogcServers[meta.ogcServer]) {ogcServer &#x3D; ogcServers[meta.ogcServer];}ogcImageType &#x3D; gmfLayerWMTS.imageType;} else if (ogcType &#x3D;&#x3D;&#x3D; gmfThemeThemes.NodeType.WMS) {// (4) Manage WMSconst gmfLayerWMS &#x3D; /** @type {gmfThemes.GmfLayerWMS} */ (gmfLayer);// Common options for WMSmaxResolution &#x3D; gmfLayerWMS.maxResolutionHint;minResolution &#x3D; gmfLayerWMS.minResolutionHint;// OGC LayersogcLayers &#x3D; gmfLayerWMS.childLayers.map((childLayer) &#x3D;&gt; {return {maxResolution: childLayer.maxResolutionHint,minResolution: childLayer.minResolutionHint,name: childLayer.name,queryable: childLayer.queryable};});// OGC Serverconst ogcServerName &#x3D; (!firstLevelGroup || firstLevelGroup.mixed) ?gmfLayerWMS.ogcServer : firstLevelGroup.ogcServer;googAsserts.assert(ogcServerName);ogcServer &#x3D; ogcServers[ogcServerName];ogcImageType &#x3D; ogcServer.imageType;// Time propertyif (gmfLayerWMS.time) {timeProperty &#x3D; gmfLayerWMS.time;} else if (firstLevelGroup &amp;&amp; firstLevelGroup.time) {timeProperty &#x3D; firstLevelGroup.time;}}// (5) ogcServerconst ogcServerType &#x3D; ogcServer ? ogcServer.type : undefined;const wfsFeatureNS &#x3D; ogcServer ? ogcServer.namespace : undefined;const wmsIsSingleTile &#x3D; ogcServer ? ogcServer.isSingleTile : undefined;const wfsUrl &#x3D; ogcServer &amp;&amp; ogcServer.wfsSupport ? ogcServer.urlWfs : undefined;const wmsUrl &#x3D; ogcServer ? ogcServer.url : undefined;let wfsOutputFormat &#x3D; ngeoDatasourceOGC.WFSOutputFormat.GML3;// qgis server only supports GML2 outputif (ogcServerType &#x3D;&#x3D;&#x3D; ngeoDatasourceOGC.ServerType.QGISSERVER) {wfsOutputFormat &#x3D; ngeoDatasourceOGC.WFSOutputFormat.GML2;}// (6) Snappingconst snappable &#x3D; !!meta.snappingConfig;const snappingTolerance &#x3D; meta.snappingConfig ? meta.snappingConfig.tolerance : undefined;const snappingToEdges &#x3D; meta.snappingConfig ? meta.snappingConfig.edge : undefined;const snappingToVertice &#x3D; meta.snappingConfig ? meta.snappingConfig.vertex : undefined;// (7) Dimensionsconst dimensions &#x3D; this.dimensions_;const dimensionsConfig &#x3D; node.dimensions || firstLevelGroup.dimensions;const dimensionsFiltersConfig &#x3D; node.dimensionsFilters;// (8) Time values (lower or lower/upper)let timeLowerValue;let timeUpperValue;if (timeProperty) {const timeValues &#x3D; this.ngeoWMSTime_.getOptions(timeProperty)[&#x27;values&#x27;];if (Array.isArray(timeValues)) {timeLowerValue &#x3D; timeValues[0];timeUpperValue &#x3D; timeValues[1];} else {timeLowerValue &#x3D; timeValues;}}// (9) Common optionsconst copyable &#x3D; meta.copyable;const identifierAttribute &#x3D; meta.identifierAttributeField;const name &#x3D; gmfLayer.name;const timeAttributeName &#x3D; meta.timeAttribute;const visible &#x3D; meta.isChecked &#x3D;&#x3D;&#x3D; true;// Create the data source and add it to the cachethis.dataSourcesCache_[id] &#x3D; new gmfDatasourceOGC({copyable,dimensions,dimensionsConfig,dimensionsFiltersConfig,gmfLayer,id,identifierAttribute,maxResolution,minResolution,name,ogcImageType,ogcLayers,ogcServerType,wfsFeatureNS,ogcType,snappable,snappingTolerance,snappingToEdges,snappingToVertice,timeAttributeName,timeLowerValue,timeProperty,timeUpperValue,visible,wfsOutputFormat,wfsUrl,wmsIsSingleTile,wmsUrl,wmtsLayer,wmtsUrl});}/*** If the given Layertree controller is a &#x27;leaf&#x27;, add it to the cache.* Also, set its according data source. Finally, add the data source to* the ngeo collection.** @param {ngeo.layertree.Controller} treeCtrl Layertree controller to add* @private*/addTreeCtrlToCache_(treeCtrl) {const id &#x3D; olUtilGetUid(treeCtrl.node);const dataSource &#x3D; this.dataSourcesCache_[id];googAsserts.assert(dataSource, &#x27;DataSource should be set&#x27;);treeCtrl.setDataSource(dataSource);const stateWatcherUnregister &#x3D; this.rootScope_.$watch(() &#x3D;&gt; treeCtrl.getState(),this.handleTreeCtrlStateChange_.bind(this, treeCtrl));const filterRulesWatcherUnregister &#x3D; this.rootScope_.$watch(() &#x3D;&gt; {const hasFilters &#x3D; dataSource.filterRules !&#x3D;&#x3D; null;const isVisible &#x3D; dataSource.visible;return hasFilters &amp;&amp; isVisible;},this.handleDataSourceFilterRulesChange_.bind(this, dataSource));// Watch for time values change to update the WMS layerlet timeLowerValueWatcherUnregister;let timeUpperValueWatcherUnregister;let wmsLayer;if (dataSource.timeProperty &amp;&amp;dataSource.ogcType &#x3D;&#x3D;&#x3D; ngeoDatasourceOGC.Type.WMS) {timeLowerValueWatcherUnregister &#x3D; this.rootScope_.$watch(() &#x3D;&gt; dataSource.timeLowerValue,this.handleDataSourceTimeValueChange_.bind(this, dataSource));if (dataSource.timeProperty.mode &#x3D;&#x3D;&#x3D; &#x27;range&#x27;) {timeUpperValueWatcherUnregister &#x3D; this.rootScope_.$watch(() &#x3D;&gt; dataSource.timeUpperValue,this.handleDataSourceTimeValueChange_.bind(this, dataSource));}wmsLayer &#x3D; googAsserts.assertInstanceof(gmfLayertreeSyncLayertreeMap.getLayer(treeCtrl),olLayerImage);}this.treeCtrlCache_[id] &#x3D; {filterRulesWatcherUnregister,stateWatcherUnregister,timeLowerValueWatcherUnregister,timeUpperValueWatcherUnregister,treeCtrl,wmsLayer};this.dataSources_.push(dataSource);this.gmfWFSAliases_.describe(dataSource);}/*** Remove a treeCtrl cache item. Unregister event listeners and remove the* data source from the ngeo collection.** @param {gmfx.datasource.ManagerTreeCtrlCacheItem} item Layertree*     controller cache item* @private*/removeTreeCtrlCacheItem_(item) {// (1) Remove data sourceconst dataSource &#x3D; item.treeCtrl.getDataSource();googAsserts.assert(dataSource, &#x27;DataSource should be set&#x27;);this.dataSources_.remove(dataSource);// (2) Remove item and clear event listenersitem.treeCtrl.setDataSource(null);item.filterRulesWatcherUnregister();item.stateWatcherUnregister();if (item.timeLowerValueWatcherUnregister) {item.timeLowerValueWatcherUnregister();}if (item.timeUpperValueWatcherUnregister) {item.timeUpperValueWatcherUnregister();}delete this.treeCtrlCache_[olUtilGetUid(item.treeCtrl.node)];}/*** Clears the layer tree controller cache. At the same time, each item gets* its data source reference unset and state watcher unregistered.** The data source gets also removed from the ngeo data sources collection.* @private*/clearTreeCtrlCache_() {for (const id in this.treeCtrlCache_) {this.removeTreeCtrlCacheItem_(this.treeCtrlCache_[id]);}}/*** Called when the state of a &#x27;leaf&#x27; layertree controller changes.* Update the &#x60;visible&#x60; property of the data source according to the* state of the layertree controller.** Note: The possible states can only be &#x27;on&#x27; or &#x27;off&#x27;, because the* layertree controller being a &#x27;leaf&#x27;.** @param {ngeo.layertree.Controller} treeCtrl The layer tree controller* @param {string|undefined} newVal New state value* @private*/handleTreeCtrlStateChange_(treeCtrl, newVal) {const treeDataSource &#x3D; treeCtrl.getDataSource();googAsserts.assert(treeDataSource, &#x27;DataSource should be set&#x27;);const visible &#x3D; newVal &#x3D;&#x3D;&#x3D; &#x27;on&#x27;;treeDataSource.visible &#x3D; visible;// In GMF, multiple data sources can be combined into one ol.layer.Layer// object. When changing the state of a data source, we need to make// sure that the FILTER param match order of the current LAYERS param.const layer &#x3D; this.getDataSourceLayer_(treeDataSource);if (layer &#x3D;&#x3D; undefined) {return;}this.updateLayerFilter_(layer);}/*** Returns a layertree controller cache item, if it exists.** @param {ngeo.layertree.Controller} treeCtrl The layer tree controller* @return {gmfx.datasource.ManagerTreeCtrlCacheItem} Cache item* @private*/getTreeCtrlCacheItem_(treeCtrl) {return this.treeCtrlCache_[olUtilGetUid(treeCtrl.node)] || null;}/*** Return the layer corresponding to the data source.* @param {!ngeo.DataSource} dataSource The data source.* @return {ol.layer.Base|undefined} The layer.* @private*/getDataSourceLayer_(dataSource) {dataSource &#x3D; /** @type {!gmf.DataSource} */ (dataSource);const id &#x3D; olUtilGetUid(dataSource.gmfLayer);const item &#x3D; this.treeCtrlCache_[id];if (item &#x3D;&#x3D; undefined) {return;}const treeCtrl &#x3D; item.treeCtrl;return gmfLayertreeSyncLayertreeMap.getLayer(treeCtrl);}/*** Update layer filter parameter according to data sources filter rules* and dimensions filters.* @param {ol.layer.Base} layer The layer to update.* @private*/updateLayerFilter_(layer) {googAsserts.assert(layer instanceof olLayerImage ||layer instanceof olLayerTile);const source &#x3D; layer.getSource();if (!(source instanceof olSourceImageWMS ||source instanceof olSourceTileWMS)) {return;}const params &#x3D; source.getParams();const layersParam &#x3D; params[&#x27;LAYERS&#x27;];const layersList &#x3D; layersParam.split(&#x27;,&#x27;);googAsserts.assert(layersList.length &gt;&#x3D; 1);const filterParam &#x3D; &#x27;FILTER&#x27;;const filterParamValues &#x3D; [];let hasFilter &#x3D; false;for (const dataSourceName of layersList) {let filterParamValue &#x3D; &#x27;()&#x27;;const dataSources &#x3D; this.dataSources_.getArray();for (const dataSource of dataSources) {const dsLayer &#x3D; this.getDataSourceLayer_(dataSource);if (dsLayer &#x3D;&#x3D; undefined) {continue;}if (olUtilGetUid(dsLayer) &#x3D;&#x3D; olUtilGetUid(layer) &amp;&amp;dataSourceName &#x3D;&#x3D;&#x3D; dataSource.name) {const id &#x3D; olUtilGetUid(dataSource.gmfLayer);const item &#x3D; this.treeCtrlCache_[id];googAsserts.assert(item);const treeCtrl &#x3D; item.treeCtrl;const projCode &#x3D; treeCtrl.map.getView().getProjection().getCode();const filterString &#x3D; dataSource.visible ?this.ngeoRuleHelper_.createFilterString({dataSource: dataSource,projCode: projCode,incDimensions: true}) :null;if (filterString) {filterParamValue &#x3D; &#x60;(${filterString})&#x60;;hasFilter &#x3D; true;}}}filterParamValues.push(filterParamValue);}source.updateParams({[filterParam]: hasFilter ? filterParamValues.join(&#x27;&#x27;) : null});}/*** Called when both the &#x27;visible&#x27; and &#x27;filterRules&#x27; properties of a data* source change.** If the data source is filtrable, then make sure that when it gets rules* set to apply them as OGC filters to the OpenLayers layer, more precisely* as a &#x60;FILTER&#x60; parameter in the layer&#x27;s source parameters.** @param {!gmf.datasource.OGC} dataSource Data source.* @private*/handleDataSourceFilterRulesChange_(dataSource) {// Skip data sources that are not filtrables OR those that do not have// the WMS ogcType, i.e. those that do not have an OpenLayers layer// to updateif (dataSource.filtrable !&#x3D;&#x3D; true ||dataSource.ogcType !&#x3D;&#x3D; ngeoDatasourceOGC.Type.WMS) {return;}const layer &#x3D; this.getDataSourceLayer_(dataSource);if (layer &#x3D;&#x3D;&#x3D; undefined) {return;}this.updateLayerFilter_(layer);}/*** Called when either the &#x60;timeLowerValue&#x60; or &#x60;timeUpperValue&#x60; property of a* data source changes.** Get the range value from the data source, then update the WMS layer* thereafter.** @param {!gmf.datasource.OGC} dataSource Data source.* @private*/handleDataSourceTimeValueChange_(dataSource) {const id &#x3D; olUtilGetUid(dataSource.gmfLayer);const item &#x3D; this.treeCtrlCache_[id];googAsserts.assert(item);const wmsLayer &#x3D; googAsserts.assert(item.wmsLayer);const wmsSource &#x3D; googAsserts.assertInstanceof(wmsLayer.getSource(),olSourceImageWMS);const timeProperty &#x3D; googAsserts.assert(dataSource.timeProperty);let timeParam;const range &#x3D; dataSource.timeRangeValue;if (range) {timeParam &#x3D; this.ngeoWMSTime_.formatWMSTimeParam(timeProperty, range);}// No need to update the TIME param if already the same value;const params &#x3D; wmsSource.getParams();const currentTimeParam &#x3D; params[&#x27;TIME&#x27;];if (currentTimeParam &#x3D;&#x3D;&#x3D; timeParam) {return;}// The &#x60;timeParam&#x60; can be undefined, which means that the TIME property// gets reset.this.ngeoLayerHelper_.updateWMSLayerState(wmsLayer,wmsSource.getParams()[&#x27;LAYERS&#x27;],timeParam);}/*** Called when the background layer changes. Add/Remove the according data* sources to/from the ngeo data sources collection. Update the data source* &#x60;visible&#x60; property as well.** The &#x60;querySourceIds&#x60; property in the layer is used to determine the* data sources that are bound to the layer.** @param {!ngeox.BackgroundEvent} evt Event.* @private*/handleNgeoBackgroundLayerChange_(evt) {const previousBackgroundLayer &#x3D; evt.detail.previous;const currentBackgroundLayer &#x3D; evt.detail.current;const cache &#x3D; this.dataSourcesCache_;// Remove data sources linked to previous background layerif (previousBackgroundLayer) {const ids &#x3D; previousBackgroundLayer.get(&#x27;querySourceIds&#x27;);if (Array.isArray(ids)) {for (const id of ids) {const dataSource &#x3D; cache[id];if (dataSource) {dataSource.visible &#x3D; false;this.dataSources_.remove(dataSource);}}}}// Add data sources linked to current background layerif (currentBackgroundLayer) {const ids &#x3D; currentBackgroundLayer.get(&#x27;querySourceIds&#x27;);if (Array.isArray(ids)) {for (const id of ids) {const dataSource &#x3D; cache[id];if (dataSource) {dataSource.visible &#x3D; true;this.dataSources_.push(dataSource);}}}}}}</span></div>
					<aside class="tsd-sources">
						<ul>
							<li>Defined in <a href="https://github.com/camptocamp/ngeo/blob/60bd072/contribs/gmf/src/datasource/Manager.js#L30">contribs/gmf/src/datasource/Manager.js:30</a></li>
						</ul>
					</aside>
				</section>
			</section>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="../globals.html"><em>Globals</em></a>
					</li>
					<li class="current tsd-kind-external-module">
						<a href="_contribs_gmf_src_datasource_manager_.html">"contribs/gmf/src/datasource/<wbr>Manager"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-variable tsd-parent-kind-external-module">
						<a href="_contribs_gmf_src_datasource_manager_.html#exports" class="tsd-kind-icon">exports</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="../assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="../assets/js/search.js"><' + '/script>');</script>
</body>
</html>